p8105\_hw1\_jv2629
================

Initial commit
--------------

Problem 1
=========

Loading tidyverse to enable tibble and create a data frame
----------------------------------------------------------

``` r
library(tidyverse)
```

    ## ── Attaching packages ──────────────────────────── tidyverse 1.2.1 ──

    ## ✔ ggplot2 3.0.0     ✔ purrr   0.2.5
    ## ✔ tibble  1.4.2     ✔ dplyr   0.7.6
    ## ✔ tidyr   0.8.1     ✔ stringr 1.3.1
    ## ✔ readr   1.1.1     ✔ forcats 0.3.0

    ## ── Conflicts ─────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()

Creating data frame with random variables
-----------------------------------------

``` r
problem1_df = tibble(
  random_samp10 = rnorm(10, mean = 0, sd = 5),
  more_than_2 = ifelse (random_samp10 > 2,"yes", "no"),
  vec_cities = c("Boston", "Miami", "NYC", "LA", "Amsterdam", "Dar es Salaam", "Kampala", "Tel Aviv", "Rome", "Stockholm"),
  vec_continent = factor(c("North America", "North America", "North America", "North America", "Europe", "Africa", "Asia", "Asia", "Europe", "Europe"))
)

help("ifelse")

problem1_df
```

    ## # A tibble: 10 x 4
    ##    random_samp10 more_than_2 vec_cities    vec_continent
    ##            <dbl> <chr>       <chr>         <fct>        
    ##  1        -6.16  no          Boston        North America
    ##  2        -1.58  no          Miami         North America
    ##  3        -0.682 no          NYC           North America
    ##  4         4.71  yes         LA            North America
    ##  5         0.510 no          Amsterdam     Europe       
    ##  6         5.46  yes         Dar es Salaam Africa       
    ##  7         4.48  yes         Kampala       Asia         
    ##  8        -1.28  no          Tel Aviv      Asia         
    ##  9         0.705 no          Rome          Europe       
    ## 10         3.33  yes         Stockholm     Europe

The data frame looks as I would expect it to look. The conditional statement appears to work properly. The character and factor variables match up as they should.

Taking the mean of each of the variables
----------------------------------------

``` r
mean(problem1_df[["random_samp10"]])
```

    ## [1] 0.9493943

``` r
mean(problem1_df[["more_than_2"]])
```

    ## Warning in mean.default(problem1_df[["more_than_2"]]): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

``` r
mean(problem1_df[["vec_cities"]])
```

    ## Warning in mean.default(problem1_df[["vec_cities"]]): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

``` r
mean(problem1_df[["vec_continent"]])
```

    ## Warning in mean.default(problem1_df[["vec_continent"]]): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

Only "random\_samp10"" returns a mean. This makes sense because it is the only data column with numerica data. "more\_than\_2", "vec\_cities", and "vec\_continent", all contain string data and thus a mean does not make sense with this data.

Changing variables to numeric
-----------------------------

``` r
help("as.numeric")
example("as.numeric")
```

    ## Warning: NAs introduced by coercion

``` r
as.numeric(problem1_df[["more_than_2"]])
```

    ## Warning: NAs introduced by coercion

``` r
as.numeric(problem1_df[["vec_cities"]])
```

    ## Warning: NAs introduced by coercion

``` r
as.numeric(problem1_df[["vec_continent"]])
```

Using as.numeric on the logical("more\_than\_2") and character ("vec\_cities") variables changes all the data to "NA" and warns us that it created these "NA" by coercion. It does not know how to interpret these strings as numbers.

Using as.numeric on the factor ("vec\_continent") varaible assigns numbers to each category, counting up using alphabetical order.
